class _ extends Error{response;request;options;constructor(t,r,s){const o=t.status||t.status===0?t.status:"",n=t.statusText||"",i=`${o} ${n}`.trim(),a=i?`status code ${i}`:"an unknown error";super(`Request failed with ${a}: ${r.method} ${r.url}`),this.name="HTTPError",this.response=t,this.request=r,this.options=s}}class R extends Error{request;constructor(t){super(`Request timed out: ${t.method} ${t.url}`),this.name="TimeoutError",this.request=t}}const w=(()=>{let e=!1,t=!1;const r=typeof globalThis.ReadableStream=="function",s=typeof globalThis.Request=="function";if(r&&s)try{t=new globalThis.Request("https://empty.invalid",{body:new globalThis.ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type")}catch(o){if(o instanceof Error&&o.message==="unsupported BodyInit type")return!1;throw o}return e&&!t})(),k=typeof globalThis.AbortController=="function",E=typeof globalThis.AbortSignal=="function"&&typeof globalThis.AbortSignal.any=="function",A=typeof globalThis.ReadableStream=="function",C=typeof globalThis.FormData=="function",T=["get","post","put","patch","head","delete"],P={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*",bytes:"*/*"},y=2147483647,U=new TextEncoder().encode("------WebKitFormBoundaryaxpyiPgbbPti10Rw").length,q=Symbol("stop"),j={json:!0,parseJson:!0,stringifyJson:!0,searchParams:!0,prefixUrl:!0,retry:!0,timeout:!0,hooks:!0,throwHttpErrors:!0,onDownloadProgress:!0,onUploadProgress:!0,fetch:!0},O={method:!0,headers:!0,body:!0,mode:!0,credentials:!0,cache:!0,redirect:!0,referrer:!0,referrerPolicy:!0,integrity:!0,keepalive:!0,signal:!0,window:!0,dispatcher:!0,duplex:!0,priority:!0},L=e=>{if(!e)return 0;if(e instanceof FormData){let t=0;for(const[r,s]of e)t+=U,t+=new TextEncoder().encode(`Content-Disposition: form-data; name="${r}"`).length,t+=typeof s=="string"?new TextEncoder().encode(s).length:s.size;return t}if(e instanceof Blob)return e.size;if(e instanceof ArrayBuffer)return e.byteLength;if(typeof e=="string")return new TextEncoder().encode(e).length;if(e instanceof URLSearchParams)return new TextEncoder().encode(e.toString()).length;if("byteLength"in e)return e.byteLength;if(typeof e=="object"&&e!==null)try{const t=JSON.stringify(e);return new TextEncoder().encode(t).length}catch{return 0}return 0},B=(e,t)=>{const r=Number(e.headers.get("content-length"))||0;let s=0;return e.status===204?(t&&t({percent:1,totalBytes:r,transferredBytes:s},new Uint8Array),new Response(null,{status:e.status,statusText:e.statusText,headers:e.headers})):new Response(new ReadableStream({async start(o){const n=e.body.getReader();t&&t({percent:0,transferredBytes:0,totalBytes:r},new Uint8Array);async function i(){const{done:a,value:h}=await n.read();if(a){o.close();return}if(t){s+=h.byteLength;const u=r===0?0:s/r;t({percent:u,transferredBytes:s,totalBytes:r},h)}o.enqueue(h),await i()}await i()}}),{status:e.status,statusText:e.statusText,headers:e.headers})},I=(e,t,r)=>{const s=L(r??e.body);let o=0;return new Request(e,{duplex:"half",body:new ReadableStream({async start(n){const i=e.body instanceof ReadableStream?e.body.getReader():new Response("").body.getReader();async function a(){const{done:h,value:u}=await i.read();if(h){t&&t({percent:1,transferredBytes:o,totalBytes:Math.max(s,o)},new Uint8Array),n.close();return}o+=u.byteLength;let f=s===0?0:o/s;(s<o||f===1)&&(f=.99),t&&t({percent:Number(f.toFixed(2)),transferredBytes:o,totalBytes:s},u),n.enqueue(u),await a()}await a()}})})},c=e=>e!==null&&typeof e=="object",l=(...e)=>{for(const t of e)if((!c(t)||Array.isArray(t))&&t!==void 0)throw new TypeError("The `options` argument must be an object");return b({},...e)},x=(e={},t={})=>{const r=new globalThis.Headers(e),s=t instanceof globalThis.Headers,o=new globalThis.Headers(t);for(const[n,i]of o.entries())s&&i==="undefined"||i===void 0?r.delete(n):r.set(n,i);return r};function d(e,t,r){return Object.hasOwn(t,r)&&t[r]===void 0?[]:b(e[r]??[],t[r]??[])}const S=(e={},t={})=>({beforeRequest:d(e,t,"beforeRequest"),beforeRetry:d(e,t,"beforeRetry"),afterResponse:d(e,t,"afterResponse"),beforeError:d(e,t,"beforeError")}),b=(...e)=>{let t={},r={},s={};for(const o of e)if(Array.isArray(o))Array.isArray(t)||(t=[]),t=[...t,...o];else if(c(o)){for(let[n,i]of Object.entries(o))c(i)&&n in t&&(i=b(t[n],i)),t={...t,[n]:i};c(o.hooks)&&(s=S(s,o.hooks),t.hooks=s),c(o.headers)&&(r=x(r,o.headers),t.headers=r)}return t},v=e=>T.includes(e)?e.toUpperCase():e,N=["get","put","head","delete","options","trace"],H=[408,413,429,500,502,503,504],$=[413,429,503],g={limit:2,methods:N,statusCodes:H,afterStatusCodes:$,maxRetryAfter:Number.POSITIVE_INFINITY,backoffLimit:Number.POSITIVE_INFINITY,delay:e=>.3*2**(e-1)*1e3},D=(e={})=>{if(typeof e=="number")return{...g,limit:e};if(e.methods&&!Array.isArray(e.methods))throw new Error("retry.methods must be an array");if(e.statusCodes&&!Array.isArray(e.statusCodes))throw new Error("retry.statusCodes must be an array");return{...g,...e}};async function J(e,t,r,s){return new Promise((o,n)=>{const i=setTimeout(()=>{r&&r.abort(),n(new R(e))},s.timeout);s.fetch(e,t).then(o).catch(n).then(()=>{clearTimeout(i)})})}async function M(e,{signal:t}){return new Promise((r,s)=>{t&&(t.throwIfAborted(),t.addEventListener("abort",o,{once:!0}));function o(){clearTimeout(n),s(t.reason)}const n=setTimeout(()=>{t?.removeEventListener("abort",o),r()},e)})}const z=(e,t)=>{const r={};for(const s in t)!(s in O)&&!(s in j)&&!(s in e)&&(r[s]=t[s]);return r},F=e=>e===void 0?!1:Array.isArray(e)?e.length>0:e instanceof URLSearchParams?e.size>0:typeof e=="object"?Object.keys(e).length>0:typeof e=="string"?e.trim().length>0:!!e;class p{static create(t,r){const s=new p(t,r),o=async()=>{if(typeof s._options.timeout=="number"&&s._options.timeout>y)throw new RangeError(`The \`timeout\` option cannot be greater than ${y}`);await Promise.resolve();let a=await s._fetch();for(const h of s._options.hooks.afterResponse){const u=await h(s.request,s._options,s._decorateResponse(a.clone()));u instanceof globalThis.Response&&(a=u)}if(s._decorateResponse(a),!a.ok&&s._options.throwHttpErrors){let h=new _(a,s.request,s._options);for(const u of s._options.hooks.beforeError)h=await u(h);throw h}if(s._options.onDownloadProgress){if(typeof s._options.onDownloadProgress!="function")throw new TypeError("The `onDownloadProgress` option must be a function");if(!A)throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");return B(a.clone(),s._options.onDownloadProgress)}return a},i=(s._options.retry.methods.includes(s.request.method.toLowerCase())?s._retry(o):o()).finally(async()=>{s.request.bodyUsed||await s.request.body?.cancel()});for(const[a,h]of Object.entries(P))a==="bytes"&&typeof globalThis.Response?.prototype?.bytes!="function"||(i[a]=async()=>{s.request.headers.set("accept",s.request.headers.get("accept")||h);const u=await i;if(a==="json"){if(u.status===204)return"";const f=await u.text();return f===""?"":r.parseJson?r.parseJson(f):JSON.parse(f)}return u[a]()});return i}static#t(t){return t&&typeof t=="object"&&!Array.isArray(t)&&!(t instanceof URLSearchParams)?Object.fromEntries(Object.entries(t).filter(([,r])=>r!==void 0)):t}request;abortController;_retryCount=0;_input;_options;constructor(t,r={}){if(this._input=t,this._options={...r,headers:x(this._input.headers,r.headers),hooks:S({beforeRequest:[],beforeRetry:[],beforeError:[],afterResponse:[]},r.hooks),method:v(r.method??this._input.method??"GET"),prefixUrl:String(r.prefixUrl||""),retry:D(r.retry),throwHttpErrors:r.throwHttpErrors!==!1,timeout:r.timeout??1e4,fetch:r.fetch??globalThis.fetch.bind(globalThis)},typeof this._input!="string"&&!(this._input instanceof URL||this._input instanceof globalThis.Request))throw new TypeError("`input` must be a string, URL, or Request");if(this._options.prefixUrl&&typeof this._input=="string"){if(this._input.startsWith("/"))throw new Error("`input` must not begin with a slash when using `prefixUrl`");this._options.prefixUrl.endsWith("/")||(this._options.prefixUrl+="/"),this._input=this._options.prefixUrl+this._input}if(k&&E){const s=this._options.signal??this._input.signal;this.abortController=new globalThis.AbortController,this._options.signal=s?AbortSignal.any([s,this.abortController.signal]):this.abortController.signal}if(w&&(this._options.duplex="half"),this._options.json!==void 0&&(this._options.body=this._options.stringifyJson?.(this._options.json)??JSON.stringify(this._options.json),this._options.headers.set("content-type",this._options.headers.get("content-type")??"application/json")),this.request=new globalThis.Request(this._input,this._options),F(this._options.searchParams)){const o="?"+(typeof this._options.searchParams=="string"?this._options.searchParams.replace(/^\?/,""):new URLSearchParams(p.#t(this._options.searchParams)).toString()),n=this.request.url.replace(/(?:\?.*?)?(?=#|$)/,o);(C&&this._options.body instanceof globalThis.FormData||this._options.body instanceof URLSearchParams)&&!(this._options.headers&&this._options.headers["content-type"])&&this.request.headers.delete("content-type"),this.request=new globalThis.Request(new globalThis.Request(n,{...this.request}),this._options)}if(this._options.onUploadProgress){if(typeof this._options.onUploadProgress!="function")throw new TypeError("The `onUploadProgress` option must be a function");if(!w)throw new Error("Request streams are not supported in your environment. The `duplex` option for `Request` is not available.");this.request.body&&(this.request=I(this.request,this._options.onUploadProgress,this._options.body))}}_calculateRetryDelay(t){if(this._retryCount++,this._retryCount>this._options.retry.limit||t instanceof R)throw t;if(t instanceof _){if(!this._options.retry.statusCodes.includes(t.response.status))throw t;const s=t.response.headers.get("Retry-After")??t.response.headers.get("RateLimit-Reset")??t.response.headers.get("X-RateLimit-Reset")??t.response.headers.get("X-Rate-Limit-Reset");if(s&&this._options.retry.afterStatusCodes.includes(t.response.status)){let o=Number(s)*1e3;Number.isNaN(o)?o=Date.parse(s)-Date.now():o>=Date.parse("2024-01-01")&&(o-=Date.now());const n=this._options.retry.maxRetryAfter??o;return o<n?o:n}if(t.response.status===413)throw t}const r=this._options.retry.delay(this._retryCount);return Math.min(this._options.retry.backoffLimit,r)}_decorateResponse(t){return this._options.parseJson&&(t.json=async()=>this._options.parseJson(await t.text())),t}async _retry(t){try{return await t()}catch(r){const s=Math.min(this._calculateRetryDelay(r),y);if(this._retryCount<1)throw r;await M(s,{signal:this._options.signal});for(const o of this._options.hooks.beforeRetry)if(await o({request:this.request,options:this._options,error:r,retryCount:this._retryCount})===q)return;return this._retry(t)}}async _fetch(){for(const s of this._options.hooks.beforeRequest){const o=await s(this.request,this._options);if(o instanceof Request){this.request=o;break}if(o instanceof Response)return o}const t=z(this.request,this._options),r=this.request;return this.request=r.clone(),this._options.timeout===!1?this._options.fetch(r,t):J(r,t,this.abortController,this._options)}}/*! MIT License © Sindre Sorhus */const m=e=>{const t=(r,s)=>p.create(r,l(e,s));for(const r of T)t[r]=(s,o)=>p.create(s,l(e,o,{method:r}));return t.create=r=>m(l(r)),t.extend=r=>(typeof r=="function"&&(r=r(e??{})),m(l(e,r))),t.stop=q,t},V=m();export{V as k};
